An informal list of issues, or explanations of potentially confusing points in
the code that warranted a longer explanation than a comment.

* 1.
Speech synthesis does not wait until completion before returning. For long
phrases, it is necessary to begin the utterance, then attach a callback to it so
that the program will proceed when the utterance is finished. This is
accomplished in the afterBeep procedure, whose comment points to this issue.

I had originally thought it would suffice to do the following, as in afterBeep:
#+BEGIN_SRC javascript
  let utterance = speak(message);
  utterance.onend = afterSpeech;
#+END_SRC

However, if you set things up as above, run the following code, and select
something from the "request" menu, you don't return to the main loop.
#+BEGIN_SRC javascript
  function testRequest() {
      const detector = makeDetector();
      const buffer = makeBuffer();
      const clock = makeClock();
      const slider = makeSlider();

      let main = makeBranchMenu({detector, slider, menuName: "main"});
      let request = makeLeafMenu({detector, slider, menuName: "request"});

      // let children = new Map([["request", request]]);
      let children = new Map([["request", request]]);
      main.addChildren(children);
      main.scan();
  }
#+END_SRC

The afterSpeech callback did not invoke when speech completed. This occurs
because utterance is defined within the scope of afterBeep. When afterBeep
exits, utterance is garbage-collected and the listener associated with it goes
away. I'm not sure whether it's a bug that objects with active listeners can be
garbage-collected, but that's another issue. Anyhow, the fix is to have
something that will never go out of scope point to the utterance object, so that
it will hang around and listen for the required event.

It does not suffice to attach the utterance to the request button object. In the
snippet above, this button goes out of scope when function invocation completes
and we're back where we started.

The best element I could think of is to attach the utterance to the DOM element
it represents; that way, unless you edit the DOM, you're safe. That's what I do
with this line:
#+BEGIN_SRC javascript
  my.buttonElem.utterance = utterance; // Not extraneous, but subtle. See issue 1.
#+END_SRC
With this, the snippet works and we're ok.
